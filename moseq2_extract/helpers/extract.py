'''
Extraction-helper utilities.
These functions are primarily called from inside the extract_wrapper() function.
'''

import os
import warnings
import numpy as np
from tqdm.auto import tqdm
from moseq2_extract.extract.proc import apply_roi
from moseq2_extract.extract.extract import extract_chunk
from moseq2_extract.io.video import load_movie_data, write_frames_preview

def process_extract_batches(f, input_file, config_data, bground_im, roi, scalars, frame_batches, first_frame_idx, \
                            true_depth, tar, strel_tail, strel_min, output_dir, output_filename):
    '''
    Given an open h5 file, which is used to store extraction results, and some pre-computed input session data points
    such as the background, ROI, etc. Compute extracted frames and save them to h5 files and avi files.
    Called from extract_wrapper()

    Parameters
    ----------
    f (h5py.File): opened h5 file to write extracted batches to
    input_file (str): path to depth file
    config_data (dict): dictionary containing extraction parameters (autogenerated)
    bground_im (2d numpy array):  r x c, background image
    roi (2d numpy array):  r x c, roi image
    scalars (list): list of keys to scalar attribute values
    frame_batches (list): list of batches of frames to serially process.
    first_frame_idx (int): index of starting frame.
    true_depth (float): computed detected true depth.
    tar (bool): compressed file indicator.
    strel_tail (cv2.StructuringElement): Element for tail filtering.
    strel_min (int): minimum kernel size
    output_dir (str): path to output directory that contains the extracted data, e.g. (proc/).
    output_filename (str): name of h5 file containing extraction data, e.g. (results_00).

    Returns
    -------
    video_pipe (bool): boolean for whether function is done writing to video file.
    '''

    video_pipe = None
    tracking_init_mean = None
    tracking_init_cov = None

    # Ensure filter kernel sizes are odd
    if config_data['spatial_filter_size'][0] % 2 == 0 and config_data['spatial_filter_size'][0] > 0:
        warnings.warn("Spatial Filter Size must be an odd number. Incrementing value by 1.")
        config_data['spatial_filter_size'][0] += 1
    if config_data['temporal_filter_size'][0] % 2 == 0 and config_data['temporal_filter_size'][0] > 0:
        config_data['temporal_filter_size'][0] += 1
        warnings.warn("Spatial Filter Size must be an odd number. Incrementing value by 1.")

    for i, frame_range in enumerate(tqdm(frame_batches, desc='Processing batches')):
        raw_frames = load_movie_data(input_file, [f + first_frame_idx for f in frame_range], tar_object=tar)
        raw_frames = bground_im - raw_frames

        raw_frames[raw_frames < config_data['min_height']] = 0
        if config_data['dilate_iterations'] == 1:
            raw_frames[raw_frames > config_data['max_height']] = config_data['max_height']
        else:
            raw_frames[raw_frames > config_data['max_height']] = 0
        raw_frames = raw_frames.astype(config_data['frame_dtype'])
        raw_frames = apply_roi(raw_frames, roi)

        results = extract_chunk(raw_frames,
                                **config_data,
                                prefilter_space=config_data['spatial_filter_size'],
                                prefilter_time=config_data['temporal_filter_size'],
                                tracking_init_mean=tracking_init_mean,
                                tracking_init_cov=tracking_init_cov,
                                strel_tail=strel_tail,
                                strel_min=strel_min,
                                true_depth=true_depth,
                                progress_bar=False)

        if i > 0:
            offset = config_data['chunk_overlap']
        else:
            offset = 0

        if config_data['use_tracking_model']:
            results['mask_frames'][results['depth_frames'] < config_data['min_height']] = config_data[
                'tracking_model_ll_clip']
            results['mask_frames'][results['mask_frames'] < config_data['tracking_model_ll_clip']] = config_data[
                'tracking_model_ll_clip']
            tracking_init_mean = results['parameters']['mean'][-(config_data['chunk_overlap'] + 1)]
            tracking_init_cov = results['parameters']['cov'][-(config_data['chunk_overlap'] + 1)]

        frame_range = frame_range[offset:]

        for scalar in scalars:
            f[f'scalars/{scalar}'][frame_range] = results['scalars'][scalar][offset:]

        f['frames'][frame_range] = results['depth_frames'][offset:]
        f['frames_mask'][frame_range] = results['mask_frames'][offset:]

        if config_data['flip_classifier']:
            f['metadata/extraction/flips'][frame_range] = results['flips'][offset:]

        nframes, rows, cols = raw_frames[offset:].shape
        output_movie = np.zeros((nframes, rows + config_data['crop_size'][0], cols + config_data['crop_size'][1]),
                                'uint16')
        output_movie[:, :config_data['crop_size'][0], :config_data['crop_size'][1]] = results['depth_frames'][offset:]
        output_movie[:, config_data['crop_size'][0]:, config_data['crop_size'][1]:] = raw_frames[offset:]

        video_pipe = write_frames_preview(
            os.path.join(output_dir, f'{output_filename}.mp4'), output_movie,
            pipe=video_pipe, close_pipe=False, fps=config_data['fps'],
            frame_range=[f + first_frame_idx for f in frame_range],
            depth_max=config_data['max_height'], depth_min=config_data['min_height'])

    return video_pipe


def run_local_extract(to_extract, config_file, skip_extracted=False):
    '''
    Runs the extract command on given list of sessions to extract on a local platform.
    This function is meant for the GUI interface to utilize the moseq2-batch extract functionality.

    Parameters
    ----------
    to_extract (list): list of paths to files to extract
    config_file (str): path to configuration file containing pre-configured extract and ROI
    skip_extracted (bool): Whether to skip already extracted session.

    Returns
    -------
    None
    '''

    for i, ext in tqdm(enumerate(to_extract), total=len(to_extract), desc='Extracting Sessions'):
        try:
            from moseq2_extract.gui import extract_command
            extract_command(ext, str(to_extract[i].replace(ext, 'proc/')), config_file=config_file, skip=skip_extracted)
        except Exception as e:
            print('Unexpected error:', e)
            print('could not extract', to_extract[i])
